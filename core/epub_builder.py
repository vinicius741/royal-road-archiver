# core/epub_builder.py
import os
import requests
import ebooklib # Added for ebooklib.ITEM_DOCUMENT
from ebooklib import epub # For epub.EpubBook etc.
from ebooklib.epub import read_epub, EpubHtml, EpubNav # Added EpubHtml, EpubNav here
from bs4 import BeautifulSoup
from typing import Optional, List # List is already here
from core.processor import remove_sentences_from_html_content # Added this import
from core.logging_utils import log_debug, log_warning # Added for enhanced fix_xhtml_titles_in_epub
import re
import uuid  # For unique identifiers
import datetime  # For publication date metadata
import traceback  # For detailed error reporting

def _sanitize_id(text: str) -> str:
    """
    Sanitizes text to be suitable for Epub UID or filename.
    Removes non-alphanumeric characters and replaces spaces with hyphens.
    """
    sanitized = re.sub(r'[^\w\s-]', '', text)
    sanitized = re.sub(r'\s+', '-', sanitized)
    return sanitized.lower()

def _load_chapter_content(file_path: str, chapter_title: str, chapter_uid: str) -> Optional[epub.EpubHtml]:
    """
    Loads an HTML file and creates an EpubHtml object.
    The content is expected to be a full HTML document generated by the processor.
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            html_content = f.read()

        if not html_content.strip():
            print(f"   WARNING: Chapter file {file_path} is empty and will be skipped.")
            return None

        # Ensure the chapter has a <title> tag
        soup = BeautifulSoup(html_content, 'html.parser')
        head = soup.find('head')
        if not head:
            head = soup.new_tag('head')
            if soup.html:
                soup.html.insert(0, head)
            else:
                # If no <html> tag, we are dealing with a fragment.
                # This case should ideally not happen for full XHTML documents.
                # However, to be robust, we can wrap the content in html if needed,
                # or decide that title injection isn't possible/meaningful here.
                # For now, let's assume an <html> tag is present or bs4 handles it.
                # If not, head might not be properly attached.
                # A more robust solution for fragments might be needed if they are common.
                pass # Or handle fragment case explicitly

        if head and not head.find('title'):
            title_tag = soup.new_tag('title')
            title_tag.string = chapter_title
            head.append(title_tag)

        html_content = str(soup)

        # Create EpubHtml item
        chapter_item = epub.EpubHtml(
            title=chapter_title,
            file_name=f'{_sanitize_id(chapter_uid)}.xhtml', # Use .xhtml extension
            uid=chapter_uid,
            lang='en' # Assuming the content is in English, can be parameterized
        )
        chapter_item.content = html_content
        return chapter_item
    except FileNotFoundError:
        print(f"ERROR: Chapter file not found: {file_path}")
        return None
    except IOError as e:
        print(f"ERROR: Could not read chapter file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"ERROR: An unexpected error occurred while loading chapter {file_path}: {e}")
        print(traceback.format_exc())
        return None

def build_epubs_for_story(
    input_folder: str,
    output_folder: str,
    chapters_per_epub: int = 50,
    author_name: str = "Unknown Author",
    story_title: str = "Unknown Story",
    cover_image_url: Optional[str] = None,
    story_description: Optional[str] = None,
    tags: Optional[List[str]] = None,
    publisher_name: Optional[str] = None
):
    """
    Builds EPUB files from processed HTML chapters.
    Divides the story into multiple EPUBs if chapters_per_epub is set.
    Includes additional metadata like cover, description, tags, and publisher.
    """
    if not os.path.isdir(input_folder):
        print(f"ERROR: Input folder '{input_folder}' not found or is not a directory.")
        return

    if not os.path.exists(output_folder):
        print(f"Creating output folder for EPUBs: {output_folder}")
        os.makedirs(output_folder, exist_ok=True)
    else:
        print(f"Using existing output folder for EPUBs: {output_folder}")

    chapter_files = sorted([f for f in os.listdir(input_folder) if f.lower().endswith((".html", ".htm"))])

    if not chapter_files:
        print(f"No HTML chapter files found in '{input_folder}' (after filtering for .html/.htm). Skipping EPUB generation.")
        return

    print(f"\nFound {len(chapter_files)} chapter files to process for EPUB creation:")

    effective_story_title = story_title
    if story_title == "Archived Royal Road Story" or story_title == "Unknown Story":
        try:
            first_chapter_path_for_title = os.path.join(input_folder, chapter_files[0])
            with open(first_chapter_path_for_title, 'r', encoding='utf-8') as f_content:
                soup_title = BeautifulSoup(f_content.read(), 'html.parser')
                h1_title_tag = soup_title.find('h1')
                if h1_title_tag and h1_title_tag.string:
                    extracted_title = h1_title_tag.string.strip()
                    extracted_title = re.sub(r"^(Chapter|CapÃ­tulo)\s*\d+\s*[:\-]\s*", "", extracted_title, flags=re.IGNORECASE).strip()
                    if extracted_title:
                        effective_story_title = extracted_title
                        print(f"   Used title from first chapter's H1 for EPUB: '{effective_story_title}'")
        except Exception as e_title:
            print(f"   WARNING: Could not extract story title from first chapter H1: {e_title}. Using provided/default title: '{story_title}'")


    total_chapters = len(chapter_files)
    effective_chapters_per_epub = chapters_per_epub if chapters_per_epub > 0 else total_chapters
    if total_chapters == 0 :
        print("Error: total_chapters is 0, cannot proceed.")
        return

    num_epubs = (total_chapters + effective_chapters_per_epub - 1) // effective_chapters_per_epub if effective_chapters_per_epub > 0 else 1

    print(f"Story will be split into {num_epubs} EPUB(s), with max {effective_chapters_per_epub} chapters per EPUB.")

    for i in range(num_epubs):
        start_index = i * effective_chapters_per_epub
        end_index = min((i + 1) * effective_chapters_per_epub, total_chapters)
        current_batch_files = chapter_files[start_index:end_index]

        if not current_batch_files:
            continue

        # Determine chapter numbers for the current batch (1-indexed)
        first_chapter_number_in_batch = start_index + 1
        last_chapter_number_in_batch = end_index

        # Update EPUB metadata title to include chapter range
        current_epub_title_suffix: str
        if num_epubs > 1:
            current_epub_title_suffix = f" (Ch {first_chapter_number_in_batch}-{last_chapter_number_in_batch})"
        elif total_chapters > 0: # Single volume
             current_epub_title_suffix = f" (Ch 1-{last_chapter_number_in_batch})" # last_chapter_number_in_batch would be total_chapters
        else: # No chapters, edge case
            current_epub_title_suffix = ""
        current_epub_title = f"{effective_story_title}{current_epub_title_suffix}"

        # New EPUB filename generation including chapter numbers
        filename_chapter_prefix = f"Ch{first_chapter_number_in_batch:03d}-Ch{last_chapter_number_in_batch:03d}"
        epub_filename_story_part = _sanitize_id(effective_story_title if effective_story_title and effective_story_title != "Unknown Story" else "story")
        epub_filename = os.path.join(output_folder, f"{filename_chapter_prefix}_{epub_filename_story_part}.epub")

        print(f"\n--- Building EPUB: {current_epub_title} ({len(current_batch_files)} chapters) ---")
        print(f"Saving to: {epub_filename}")

        book = epub.EpubBook()
        book.set_identifier(f"urn:uuid:{uuid.uuid5(uuid.NAMESPACE_DNS, current_epub_title)}") # Use updated title for UID
        book.set_title(current_epub_title)
        book.add_author(author_name)
        book.set_language('en')

        # Publisher
        if publisher_name and publisher_name.strip():
            book.add_metadata('DC', 'publisher', publisher_name)
        else:
            book.add_metadata('DC', 'publisher', 'Royal Road Archiver') # Default

        book.add_metadata('DC', 'date', datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), {'id': 'pubdate'})

        # Description
        if story_description and story_description.strip():
            book.add_metadata('DC', 'description', story_description)
        else:
            book.add_metadata('DC', 'description', f"Archived from Royal Road - {current_epub_title}") # Default

        # Tags (Subjects)
        if tags: # Check if tags list is not None and not empty
            for tag_string in tags:
                if tag_string and tag_string.strip(): # Ensure tag is not empty
                    book.add_metadata('DC', 'subject', tag_string.strip())

        # Cover Image
        if cover_image_url:
            try:
                print(f"   Attempting to download cover image from: {cover_image_url}")
                response = requests.get(cover_image_url, stream=True, timeout=15)
                response.raise_for_status()
                
                image_content = response.content
                content_type = response.headers.get('Content-Type')
                
                image_filename = "cover.jpg" # Default filename
                if content_type:
                    if 'image/jpeg' in content_type:
                        image_filename = "cover.jpg"
                    elif 'image/png' in content_type:
                        image_filename = "cover.png"
                    elif 'image/gif' in content_type:
                        image_filename = "cover.gif"
                    elif 'image/webp' in content_type: 
                        print(f"   WARNING: Cover image is WEBP ({content_type}), which might not be universally supported in EPUBs. Attempting as JPEG.")
                        image_filename = "cover.webp" 
                    else:
                        print(f"   WARNING: Unknown cover image Content-Type '{content_type}'. Defaulting to cover.jpg.")
                else: # Try to infer from URL
                    url_ext = os.path.splitext(cover_image_url)[1].lower()
                    if url_ext in ['.jpg', '.jpeg']:
                        image_filename = "cover.jpg"
                    elif url_ext == '.png':
                        image_filename = "cover.png"
                    elif url_ext == '.gif':
                         image_filename = "cover.gif"
                    else:
                        print("   WARNING: Could not determine cover image type from headers or URL. Defaulting to cover.jpg.")

                book.set_cover(image_filename, image_content) 
                print(f"   Cover image '{image_filename}' added to EPUB.")

                # Ensure cover.xhtml has the title "Cover"
                for item in book.get_items_of_type(ebooklib.ITEM_DOCUMENT): # Changed to ebooklib.ITEM_DOCUMENT
                    if item.get_name() == 'cover.xhtml' or item.file_name == 'cover.xhtml': # Check both name and file_name for robustness
                        try:
                            cover_html_content = item.get_content().decode('utf-8')
                            cover_soup = BeautifulSoup(cover_html_content, 'html.parser')

                            head = cover_soup.find('head')
                            if not head:
                                head = cover_soup.new_tag('head')
                                # Try to insert it into <html>, or at the beginning if no <html>
                                html_tag = cover_soup.find('html')
                                if html_tag:
                                    html_tag.insert(0, head)
                                else:
                                    cover_soup.insert(0, head)

                            title_tag = head.find('title')
                            if not title_tag:
                                title_tag = cover_soup.new_tag('title')
                                head.append(title_tag)

                            title_tag.string = "Cover"
                            item.set_content(str(cover_soup).encode('utf-8'))
                            print(f"   Updated title for '{item.file_name}' to 'Cover'.")
                        except Exception as e_cover_title:
                            print(f"   WARNING: Could not update title for cover.xhtml: {e_cover_title}")
                        break # Found and processed cover.xhtml, no need to continue loop

            except requests.exceptions.RequestException as e_cover:
                print(f"   WARNING: Failed to download cover image from {cover_image_url}: {e_cover}")
            except Exception as e_cover_generic:
                print(f"   WARNING: An unexpected error occurred while processing cover image: {e_cover_generic}")

        style_content = """
body { font-family: sans-serif; line-height: 1.6; margin: 1em; padding: 0; background-color: #fdfdfd; color: #111; }
h1, h2, h3, h4, h5, h6 { font-family: serif; margin-top: 1.5em; margin-bottom: 0.5em; line-height: 1.2; color: #333; }
h1 { font-size: 2em; text-align: center; }
h2 { font-size: 1.75em; }
p { margin-bottom: 1em; text-align: justify; text-indent: 1.5em; }
p.noindent { text-indent: 0; }
hr { border: 0; height: 1px; background: #ccc; margin: 2em auto; width: 50%;}
.chapter-content { max-width: 800px; margin: 0 auto; padding: 1em; }
img, svg { max-width: 100%; height: auto; display: block; margin: 1em auto; border: 1px solid #eee; }
        """
        default_css = epub.EpubItem(uid="style_default", file_name="style/default.css", media_type="text/css", content=style_content.encode('utf-8'))
        book.add_item(default_css)

        epub_chapters_for_spine = []
        epub_toc_links = []

        for chap_idx, chapter_file_name in enumerate(current_batch_files):
            full_chapter_path = os.path.join(input_folder, chapter_file_name)
            
            chapter_display_title_from_h1 = f"Chapter {start_index + chap_idx + 1}" # Fallback
            try:
                with open(full_chapter_path, 'r', encoding='utf-8') as f_chap:
                    chap_soup = BeautifulSoup(f_chap.read(), 'html.parser')
                    h1_tag = chap_soup.find('h1')
                    if h1_tag and h1_tag.string:
                        chapter_display_title_from_h1 = h1_tag.string.strip()
            except Exception as e_chap_title:
                print(f"   WARNING: Could not read H1 title from {chapter_file_name}: {e_chap_title}. Using fallback title.")

            chapter_uid = f"chap_{_sanitize_id(os.path.splitext(chapter_file_name)[0])}_{i}_{chap_idx}"

            epub_chapter = _load_chapter_content(full_chapter_path, chapter_display_title_from_h1, chapter_uid)

            if epub_chapter:
                epub_chapter.add_item(default_css) 
                book.add_item(epub_chapter)
                epub_chapters_for_spine.append(epub_chapter)
                epub_toc_links.append(epub.Link(href=epub_chapter.file_name, title=chapter_display_title_from_h1, uid=chapter_uid))
                print(f"   Added chapter to EPUB: {chapter_display_title_from_h1} (File: {epub_chapter.file_name})")
            else:
                print(f"   WARNING: Could not load content for chapter {chapter_file_name}. It will be skipped.")

        if not epub_chapters_for_spine:
            print(f"WARNING: No chapters were successfully prepared for EPUB '{current_epub_title}'. Skipping save.")
            continue

        book.toc = tuple(epub_toc_links)
        book.add_item(epub.EpubNcx())
        book.add_item(epub.EpubNav()) 

        book.spine = ['nav'] + epub_chapters_for_spine

        try:
            print(f"   Attempting to write EPUB file: {epub_filename}")
            epub.write_epub(epub_filename, book, {"epub3_pages": False, "toc_depth": 2})
            print(f"Successfully created EPUB: {epub_filename}")
        except Exception as e_write:
            print(f"ERROR: Could not save EPUB '{epub_filename}': {e_write}")
            print(f"Traceback for EPUB write error:\n{traceback.format_exc()}")

    print("\nEPUB generation process concluded.")


def load_epub_for_modification(epub_file_path: str) -> Optional[epub.EpubBook]:
    """Loads an EPUB file for modification.

    Args:
        epub_file_path: The path to the EPUB file.

    Returns:
        The EpubBook object if successful, None otherwise.
    """
    try:
        book = read_epub(epub_file_path)
        return book
    except FileNotFoundError:
        print(f"Error: EPUB file not found at {epub_file_path}")
        return None
    except epub.EpubException as e:
        print(f"Error reading EPUB file {epub_file_path}: {e}")
        return None


def modify_epub_content(epub_path: str, sentences_to_remove: List[str]):
    """Modifies the content of an EPUB file by removing specified sentences.

    Args:
        epub_path: The path to the EPUB file.
        sentences_to_remove: A list of sentences to remove.
    """
    book = load_epub_for_modification(epub_path)
    if not book:
        print(f"Error: Could not load EPUB: {epub_path}")
        return

    modified = False
    for item in book.get_items():
        if isinstance(item, (EpubHtml, EpubNav)): # Check for EpubHtml or EpubHtmlNav
            try:
                original_html_content = item.get_content().decode('utf-8', errors='ignore')
                modified_html_content = remove_sentences_from_html_content(original_html_content, sentences_to_remove)

                if original_html_content != modified_html_content:
                    item.set_content(modified_html_content.encode('utf-8'))
                    modified = True
            except Exception as e:
                print(f"Error processing item {item.get_name()} in {epub_path}: {e}")

    if modified:
        output_epub_path = epub_path # Overwrite original file
        # Optional: Backup original file
        # backup_path = epub_path + ".bak"
        # try:
        #     os.rename(epub_path, backup_path)
        #     print(f"Backup of original EPUB created at: {backup_path}")
        # except OSError as e:
        #     print(f"Error creating backup for {epub_path}: {e}. Proceeding without backup.")

        try:
            epub.write_epub(output_epub_path, book, {}) # epub.write_epub options can be added if needed
            print(f"Successfully modified and saved EPUB: {output_epub_path}")
        except Exception as e:
            print(f"Error saving modified EPUB {output_epub_path}: {e}")
            # Optional: Restore backup if saving failed
            # if os.path.exists(backup_path):
            #     try:
            #         os.rename(backup_path, epub_path)
            #         print(f"Restored original EPUB from backup: {epub_path}")
            #     except OSError as re:
            #         print(f"Error restoring backup for {epub_path}: {re}")
    else:
        print(f"No changes made to EPUB: {epub_path}")


def fix_xhtml_titles_in_epub(book: epub.EpubBook) -> bool:
    """
    Scans all XHTML items in an EpubBook and ensures they have a <title> tag
    in their <head> section.

    For chapter files, it tries to use the item's manifest title if available and sensible,
    otherwise generates a title from the filename.
    For 'cover.xhtml', it sets the title to 'Cover'.

    Args:
        book: The ebooklib.epub.EpubBook object to modify.

    Returns:
        True if any modifications were made to the book's items, False otherwise.
    """
    overall_modified_status = False
    log_debug(f"Starting fix_xhtml_titles_in_epub for book with main title (from OPF): {book.title}")

    for item in book.get_items_of_type(ebooklib.ITEM_DOCUMENT):
        if not (item.get_name().lower().endswith(('.xhtml', '.html'))):
            log_debug(f"Skipping non-XHTML/HTML item: {item.get_name()} (Type: {item.get_type()})")
            continue

        # Temporarily comment out skipping cover.xhtml to test new string logic on it
        # if item.get_name().lower() == 'cover.xhtml':
        #     log_debug(f"Skipping title processing for cover.xhtml item: {item.get_name()}")
        #     continue

        log_debug(f"Processing item with STRING OPS: {item.get_name()} (ID: {item.id}, Type: {item.get_type()})")
        item_modified_this_iteration = False # Renamed from made_change_by_str_manip for consistency

        try:
            item_content_str = item.get_content().decode('utf-8', errors='ignore')
            modified_content_str = item_content_str

            # --- Determine desired_title_text (reusing existing logic) ---
            desired_title_text = ""
            # Specific logic for cover page title
            if item.get_name().lower() == 'cover.xhtml': # Check filename for cover
                desired_title_text = "Cover"
                log_debug(f"  Identified as cover page by name. Desired HTML <title>: '{desired_title_text}'")
            elif item.id.lower() == 'cover': # Check item ID for cover (common for programmatically added covers)
                desired_title_text = "Cover"
                log_debug(f"  Identified as cover page by ID. Desired HTML <title>: '{desired_title_text}'")
            else:
                # Generic logic for other items
                if hasattr(item, 'title') and item.title and item.title.strip().lower() not in ['none', 'untitled', '']:
                    desired_title_text = item.title.strip()
                    log_debug(f"  Using item manifest (OPF/NCX) title for HTML <title>. Desired: '{desired_title_text}' for {item.get_name()}")
                else:
                    log_debug(f"  Manifest (OPF/NCX) title is absent or generic for {item.get_name()}. Deriving from filename.")
                    filename_sans_ext = os.path.splitext(item.get_name())[0]
                    processed_filename = filename_sans_ext.replace('_', ' ').replace('-', ' ')
                    desired_title_text = ' '.join(word.capitalize() for word in processed_filename.split() if word)
                    if not desired_title_text:
                        desired_title_text = "Untitled Document" # Changed from "Untitled Content" for consistency
                    log_debug(f"  Derived HTML <title> from filename: '{desired_title_text}' for {item.get_name()}")

            if not desired_title_text.strip(): # Final fallback, though less likely now
                desired_title_text = "Untitled Document"
                log_warning(f"  Desired title for {item.get_name()} was empty or whitespace after all checks. Corrected to fallback: '{desired_title_text}'")

            import html
            escaped_desired_title_text = html.escape(desired_title_text)
            temp_title_placeholder = "___TEMP_TITLE_PLACEHOLDER___"
            head_with_temp_title_payload = f"<title>{temp_title_placeholder}</title>" # Just the title tag with placeholder

            # --- String manipulation logic ---
            next_content_str = modified_content_str

            # Case 1: <head/> (self-closing, possibly with spaces and attributes)
            # Replaces <head .../> with <head ...><title>PLACEHOLDER</title></head>
            # Captures attributes in group 1 to preserve them.
            def replace_self_closing_head(match):
                attrs = match.group(1) if match.group(1) else ""
                return f"<head{attrs}>{head_with_temp_title_payload}</head>"

            next_content_str = re.sub(r"<head(\s*[^>]*)/>", replace_self_closing_head, modified_content_str, count=1, flags=re.IGNORECASE)
            if next_content_str != modified_content_str:
                modified_content_str = next_content_str
                item_modified_this_iteration = True
                log_debug(f"  String Case 1: Replaced self-closing <head/> for {item.get_name()}")

            # Case 2: <head></head> (empty head tags)
            # Replaces <head></head> with <head><title>PLACEHOLDER</title></head>
            # Also handles <head attributes></head attributes>
            if not item_modified_this_iteration:
                def replace_empty_head(match):
                    attrs = match.group(1) if match.group(1) else ""
                    return f"<head{attrs}>{head_with_temp_title_payload}</head>"

                next_content_str = re.sub(r"<head(\s*[^>]*)>\s*</head\s*>", replace_empty_head, modified_content_str, count=1, flags=re.IGNORECASE)
                if next_content_str != modified_content_str:
                    modified_content_str = next_content_str
                    item_modified_this_iteration = True
                    log_debug(f"  String Case 2: Replaced empty <head></head> for {item.get_name()}")

            # Case 3: <head><title>...</title></head> (existing title, update it)
            if not item_modified_this_iteration:
                def replace_existing_title(match):
                    head_attrs = match.group(1) if match.group(1) else ""
                    content_before_title = match.group(2) if match.group(2) else ""
                    content_after_title = match.group(4) if match.group(4) else ""
                    # Check if the existing title is already the desired one (after placeholder substitution)
                    # This check is somewhat redundant if the final replacement of placeholder handles it,
                    # but can prevent unnecessary flagging of modification if old_title_content was already desired_title_text
                    old_title_content = match.group(3)
                    if html.unescape(old_title_content) == desired_title_text: # Compare unescaped existing to unescaped desired
                         # No change needed if title content is already correct (ignoring placeholder for now)
                         # We must return the original full match to signal no change to re.sub
                         # However, re.sub will report a change if the string differs even if semantically same.
                         # For simplicity, always replace with placeholder, then check content at the end.
                         pass # Fallthrough to replace with placeholder.

                    return f"<head{head_attrs}>{content_before_title}<title>{temp_title_placeholder}</title>{content_after_title}</head>"

                # Pattern: <head(attributes)>(anything before title)<title>(old_title_content)</title>(anything after title)</head>
                # Using DOTALL for content that might span newlines. Non-greedy match for content.
                next_content_str = re.sub(r"<head([^>]*)>\s*(.*?)\s*<title>(.*?)</title>\s*(.*?)\s*</head>",
                                          replace_existing_title,
                                          modified_content_str, count=1, flags=re.IGNORECASE | re.DOTALL)
                if next_content_str != modified_content_str: # This means regex made a structural replacement
                    modified_content_str = next_content_str
                    item_modified_this_iteration = True # Flag that a replacement happened
                    log_debug(f"  String Case 3: Existing <title> structure found and replaced with placeholder for {item.get_name()}")
                elif temp_title_placeholder not in next_content_str and re.search(r"<head[^>]*>.*?<title>.*?</title>.*?</head>", modified_content_str, flags=re.IGNORECASE | re.DOTALL):
                    # This case means re.sub didn't change the string because the replace_existing_title returned the original match
                    # (e.g. if we had a more complex check there).
                    # However, we still need to check if the *content* of the title needs updating.
                    # This part is complex. Let's simplify: if Case 3's regex matches, we assume a title exists.
                    # We'll replace the placeholder later. If the title content was already correct, the final string won't change.
                    # The item_modified_this_iteration is primarily for structural changes or if title content changes.
                    # A simpler check: if the regex matches but string is same, the title content might need updating.
                    # This is handled by the final placeholder replacement and comparison.
                    pass


            # Case 4: <head> without <title> but possibly other content
            if not item_modified_this_iteration:
                def add_title_to_existing_head(match):
                    head_attrs = match.group(1) if match.group(1) else ""
                    head_content = match.group(2) if match.group(2) else ""
                    # Defensive check: if a title somehow exists (e.g. partial match from other cases), don't add another
                    if re.search(r"<title\s*>", head_content, flags=re.IGNORECASE):
                        return match.group(0) # Return original match if title already present
                    return f"<head{head_attrs}>{head_with_temp_title_payload}{head_content}</head>"

                # Pattern: <head (attributes)> (content) </head>
                # This should only apply if previous cases (which are more specific for title presence) didn't match.
                next_content_str = re.sub(r"<head([^>]*)>(.*?)</head>",
                                          add_title_to_existing_head,
                                          modified_content_str, count=1, flags=re.IGNORECASE | re.DOTALL)
                if next_content_str != modified_content_str and temp_title_placeholder in next_content_str:
                    modified_content_str = next_content_str
                    item_modified_this_iteration = True
                    log_debug(f"  String Case 4: Added <title> to existing non-empty <head> for {item.get_name()}")

            # Case 5: No <head> tag at all. Add <head><title>...</title></head> after <html> tag.
            # This check should run regardless of item_modified_this_iteration from previous steps,
            # but only if a head tag wasn't effectively created/populated by previous steps.
            # A simple check is if temp_title_placeholder is already in modified_content_str.
            if temp_title_placeholder not in modified_content_str and not re.search(r"<head\s*>", modified_content_str, flags=re.IGNORECASE):
                def insert_head_after_html_tag(match_obj):
                    html_attributes = match_obj.group(1) if match_obj.group(1) else ""
                    # Construct new head with title placeholder
                    new_head_with_title = f"<head><title>{temp_title_placeholder}</title></head>"
                    return f"<html{html_attributes}>{new_head_with_title}"

                next_content_str = re.sub(r"<html([^>]*)>", insert_head_after_html_tag, modified_content_str, count=1, flags=re.IGNORECASE | re.DOTALL)
                if next_content_str != modified_content_str:
                    modified_content_str = next_content_str
                    item_modified_this_iteration = True
                    log_debug(f"  String Case 5: Added new <head> with <title> for {item.get_name()} (no head was present).")

            # After all regex attempts, if a placeholder was inserted, replace it with the actual desired title.
            if temp_title_placeholder in modified_content_str:
                final_replaced_content_str = modified_content_str.replace(temp_title_placeholder, escaped_desired_title_text)
                # Only flag as modified if the final content (with real title) is different from original
                # OR if item_modified_this_iteration was already true (structural change)
                if final_replaced_content_str != item_content_str:
                    item_modified_this_iteration = True
                    log_debug(f"  Final title for {item.get_name()}: '{desired_title_text}' (escaped: '{escaped_desired_title_text}')")
                modified_content_str = final_replaced_content_str

            # Ensure XHTML namespace on html tag (can be done with regex too, or kept from BS4 logic if simpler)
            # For string manipulation, this is more complex if <html> itself is missing.
            # Assuming <html> tag exists based on typical XHTML structure.
            if not re.search(r'<html[^>]*xmlns\s*=\s*["\']http://www.w3.org/1999/xhtml["\']', modified_content_str, flags=re.IGNORECASE):
                def add_xhtml_namespace(match_obj):
                    current_attrs = match_obj.group(1)
                    if 'xmlns=' in current_attrs: # If xmlns is there but different, replace (complex) or just log. For now, just add if totally missing.
                        return match_obj.group(0) # Don't change if xmlns present, even if wrong, for simplicity here.
                    return f"<html{current_attrs} xmlns=\"http://www.w3.org/1999/xhtml\""

                next_content_str = re.sub(r"<html([^>]*)>", add_xhtml_namespace, modified_content_str, count=1, flags=re.IGNORECASE)
                if next_content_str != modified_content_str:
                     modified_content_str = next_content_str
                     item_modified_this_iteration = True # This is a modification
                     log_debug(f"  String Ensure XHTML namespace: Added xmlns attribute for {item.get_name()}")


            # Update item content if modified
            if item_modified_this_iteration:
                # Conditional print for chap1.xhtml (as requested for debugging)
                if item.get_name().lower() == 'chap1.xhtml':
                    print(f"DEBUG_JULES: Final content for chap1.xhtml before set_content: {modified_content_str}")

                item.content = modified_content_str.encode('utf-8') # Use direct assignment as per prompt example
                overall_modified_status = True
                log_debug(f"  Item '{item.get_name()}' content was MODIFIED by string ops and updated.")
            else:
                log_debug(f"  No modifications to HTML content for item '{item.get_name()}'.")

        except Exception as e:
            log_warning(f"  ERROR processing item {item.get_name()} in fix_xhtml_titles_in_epub: {e}")
            # import traceback # Consider adding for very detailed debugging if needed by user
            # log_debug(traceback.format_exc())

    log_debug(f"Finished fix_xhtml_titles_in_epub for book. Overall modified status: {overall_modified_status}")
    return overall_modified_status


def modify_xhtml_string_for_head_and_title(xhtml_content_str: str, desired_title: str) -> tuple[str, bool]:
    """
    Modifies an XHTML content string to ensure it has a <head> and <title> tag,
    with the title content set to the desired_title.
    Uses string manipulation with regular expressions.

    Args:
        xhtml_content_str: The original XHTML content as a string.
        desired_title: The desired raw title string (will be HTML-escaped).

    Returns:
        A tuple: (modified_xhtml_content_str, was_modified_flag).
    """
    original_input_str = xhtml_content_str # Keep a copy of the absolute original for final comparison
    modified_content_str = xhtml_content_str
    # made_change_structurally tracks if regexes for head/title structure were applied.
    # The final was_modified_flag will be based on overall string comparison.
    made_change_structurally = False

    if not desired_title: # Fallback for empty desired_title
        desired_title = "Untitled Document"
        # Use log_warning from the correct import at the top of the file
        # from core.logging_utils import log_warning
        log_warning(f"  modify_xhtml_string_for_head_and_title received empty desired_title for a document, using 'Untitled Document'.")

    import html # Ensure html module is imported for escaping
    escaped_desired_title = html.escape(desired_title)
    temp_title_placeholder = "___TEMP_TITLE_PLACEHOLDER___"

    head_with_title_placeholder_minimal = f"<head><title>{temp_title_placeholder}</title></head>"

    # 1. Ensure XHTML Namespace on <html> tag
    # Using a two-step approach for robustness as discussed in the prompt.
    html_tag_match = re.search(r"<html[^>]*>", modified_content_str, flags=re.IGNORECASE)
    if html_tag_match:
        current_html_tag = html_tag_match.group(0)
        new_html_tag = current_html_tag
        # Check if the correct xmlns is already present (case-insensitive for attribute name, sensitive for value)
        if not re.search(r'xmlns\s*=\s*["\']http://www.w3.org/1999/xhtml["\']', current_html_tag):
            if 'xmlns=' in current_html_tag.lower(): # Check if any xmlns is present
                # Replace existing xmlns attribute
                new_html_tag = re.sub(r'xmlns\s*=\s*["\'][^"\']*["\']', 'xmlns="http://www.w3.org/1999/xhtml"', current_html_tag, count=1, flags=re.IGNORECASE)
            else:
                # Add xmlns attribute
                new_html_tag = current_html_tag[:-1] + ' xmlns="http://www.w3.org/1999/xhtml">'

            if new_html_tag != current_html_tag:
                # Replace the old html tag with the new one in the whole document string
                # This assumes the first <html> tag is the one to change.
                modified_content_str = modified_content_str.replace(current_html_tag, new_html_tag, 1)
                # This change will be caught by the final comparison: (modified_content_str != original_input_str)
                log_debug("  String Ensure: Added/corrected XHTML namespace on <html> tag.")
    else:
        log_warning("  No <html> tag found. Cannot ensure XHTML namespace.")


    # --- Head and Title Manipulation ---

    # Case 1: <head .../> (self-closing, possibly with spaces and attributes)
    def replace_self_closing_head_with_title(match):
        attrs = match.group(1) if match.group(1) else ""
        # Preserve attributes correctly
        return f"<head{attrs}><title>{temp_title_placeholder}</title></head>"

    next_content = re.sub(r"<head(\s*[^>]*)/>", replace_self_closing_head_with_title, modified_content_str, count=1, flags=re.IGNORECASE)
    if next_content != modified_content_str:
        modified_content_str = next_content
        made_change_structurally = True
        log_debug("  String Case 1: Replaced self-closing <head/>.")

    # Case 2: <head ...></head> (empty or whitespace-only content)
    if not made_change_structurally:
        def replace_empty_head_with_title(match):
            attrs = match.group(1) if match.group(1) else ""
            return f"<head{attrs}><title>{temp_title_placeholder}</title></head>"

        next_content = re.sub(r"<head(\s*[^>]*)>\s*</head\s*>", replace_empty_head_with_title, modified_content_str, count=1, flags=re.IGNORECASE)
        if next_content != modified_content_str:
            modified_content_str = next_content
            made_change_structurally = True
            log_debug("  String Case 2: Replaced empty <head></head>.")

    # Case 3: <head ...><title>...</title>...</head> (existing title, update it)
    if not made_change_structurally:
        def replace_title_in_head_content(match):
            head_attrs = match.group(1) if match.group(1) else ""
            content_before_title = match.group(2) if match.group(2) else ""
            content_after_title = match.group(4) if match.group(4) else ""
            return f"<head{head_attrs}>{content_before_title}<title>{temp_title_placeholder}</title>{content_after_title}</head>"

        next_content = re.sub(r"<head([^>]*)>\s*(.*?)\s*<title>.*?</title>\s*(.*?)\s*</head>",
                              replace_title_in_head_content,
                              modified_content_str, count=1, flags=re.IGNORECASE | re.DOTALL)
        if next_content != modified_content_str:
            modified_content_str = next_content
            made_change_structurally = True
            log_debug("  String Case 3: Updated existing <title> in <head> (placeholder inserted).")

    # Case 4: <head ...>NO_TITLE_HERE</head> (head exists, no title, possibly other content)
    if not made_change_structurally:
        def add_title_to_head_content(match):
            head_attrs = match.group(1) if match.group(1) else ""
            head_content = match.group(2) if match.group(2) else ""
            if re.search(r"<title\s*>", head_content, flags=re.IGNORECASE): # Check if title somehow exists
                return match.group(0)
            return f"<head{head_attrs}><title>{temp_title_placeholder}</title>{head_content}</head>"

        next_content = re.sub(r"<head([^>]*)>(.*?)</head>",
                              add_title_to_head_content,
                              modified_content_str, count=1, flags=re.IGNORECASE | re.DOTALL)
        if next_content != modified_content_str and temp_title_placeholder in next_content:
            modified_content_str = next_content
            made_change_structurally = True
            log_debug("  String Case 4: Added <title> to existing <head> with other content.")

    # Case 5: No <head> tag at all. Add <head><title>...</title></head> after opening <html> tag.
    if not made_change_structurally and not re.search(r"<head\s*>", modified_content_str, flags=re.IGNORECASE):
        def insert_head_after_html_tag(match):
            html_tag_and_attrs = match.group(1)
            return f"{html_tag_and_attrs}{head_with_title_placeholder_minimal}"

        next_content = re.sub(r"(<html[^>]*>)", insert_head_after_html_tag, modified_content_str, count=1, flags=re.IGNORECASE | re.DOTALL)
        if next_content != modified_content_str:
            modified_content_str = next_content
            made_change_structurally = True
            log_debug("  String Case 5: Added new <head> with <title> (no <head> was present).")

    # Final title replacement
    if temp_title_placeholder in modified_content_str:
        modified_content_str = modified_content_str.replace(temp_title_placeholder, escaped_desired_title)
        # If made_change_structurally was already true, this step is part of that change.
        # If made_change_structurally was false, but placeholder is present (e.g. error in logic above),
        # and replacing it changes content, this should also be a change.
        # The final comparison to original_input_str will determine the ultimate 'was_modified_flag'.
        log_debug(f"  Replaced placeholder with actual title: '{escaped_desired_title}'")

    was_modified_flag = (modified_content_str != original_input_str)
    if was_modified_flag:
        log_debug(f"  Content was modified overall by string operations. Final title: '{desired_title}'")
    # else:
        # log_debug(f"  Content was NOT modified overall by string operations. Desired title was '{desired_title}'.")

    return modified_content_str, was_modified_flag


def get_xhtml_files_and_titles_from_epub(epub_path: str) -> list[tuple[str, str, str | None]]:
    """
    Reads an EPUB file and extracts information about its XHTML/HTML documents,
    including their filepaths within the archive, desired HTML titles, and item IDs.

    The desired HTML title is determined based on:
    1. Being "Cover" if the filename is 'cover.xhtml'.
    2. The item's manifest title (item.title) if available and not generic.
    3. A title derived from the filename if the manifest title is unsuitable.
    4. "Untitled Document" as a final fallback.

    Args:
        epub_path: The path to the EPUB file.

    Returns:
        A list of tuples, where each tuple contains:
        (filepath_in_archive: str, desired_html_title: str, item_id: str | None).
        Returns an empty list if the EPUB cannot be read or contains no XHTML documents.
    """
    xhtml_data_list = []

    if not os.path.exists(epub_path):
        log_error(f"EPUB file not found at: {epub_path}")
        return xhtml_data_list

    try:
        log_debug(f"Reading EPUB file: {epub_path}")
        book = epub.read_epub(epub_path)
    except Exception as e:
        log_error(f"Error reading EPUB file {epub_path}: {e}")
        # Depending on desired behavior, could re-raise or return empty:
        # raise # Re-raises the caught exception
        return xhtml_data_list

    log_debug(f"Successfully read EPUB. Processing items...")
    for item in book.get_items():
        if item.get_type() == ebooklib.ITEM_DOCUMENT and \
           item.get_name().lower().endswith(('.xhtml', '.html')):

            filepath_in_archive = item.get_name()
            item_id = getattr(item, 'id', None) # Safely get item.id
            desired_html_title = ""

            log_debug(f"  Processing document item: ID='{item_id}', Name='{filepath_in_archive}'")

            # Determine desired_html_title
            if filepath_in_archive.lower() == 'cover.xhtml':
                desired_html_title = "Cover"
                log_debug(f"    Item identified as cover. Desired title: '{desired_html_title}'")
            else:
                manifest_title = getattr(item, 'title', None)
                if manifest_title and manifest_title.strip().lower() not in ['', 'none', 'untitled']:
                    desired_html_title = manifest_title.strip()
                    log_debug(f"    Using manifest title: '{desired_html_title}' (from item.title: '{manifest_title}')")
                else:
                    if manifest_title:
                        log_debug(f"    Manifest title '{manifest_title}' is unsuitable. Deriving from filename.")
                    else:
                        log_debug(f"    No manifest title. Deriving from filename.")

                    filename_sans_ext = os.path.splitext(filepath_in_archive)[0]
                    # Basic processing: replace underscores/hyphens with spaces, then capitalize words
                    processed_filename = filename_sans_ext.replace('_', ' ').replace('-', ' ')
                    title_words = [word.capitalize() for word in processed_filename.split() if word]
                    derived_title = ' '.join(title_words)

                    if derived_title:
                        desired_html_title = derived_title
                        log_debug(f"    Derived title from filename: '{desired_html_title}'")
                    else:
                        # This case should be rare if filename is not empty/just symbols
                        desired_html_title = "Untitled Document"
                        log_debug(f"    Filename derivation resulted in empty title. Using fallback: '{desired_html_title}'")

            # Final fallback if somehow still empty (e.g. if cover logic was more complex and failed)
            if not desired_html_title.strip():
                desired_html_title = "Untitled Document"
                log_warning(f"    Title for '{filepath_in_archive}' was empty after all checks. Using fallback: '{desired_html_title}'")

            xhtml_data_list.append((filepath_in_archive, desired_html_title, item_id))
            log_debug(f"    Appended to list: ('{filepath_in_archive}', '{desired_html_title}', '{item_id}')")

    log_debug(f"Finished processing. Found {len(xhtml_data_list)} XHTML/HTML documents.")
    return xhtml_data_list
