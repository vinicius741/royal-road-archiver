# core/epub_builder.py
import os
from ebooklib import epub
from bs4 import BeautifulSoup
import re
import uuid # For unique identifiers
import datetime # For publication date metadata

# Helper function to sanitize filenames for UIDs and file_names
def _sanitize_id(text: str) -> str:
    """
    Sanitizes text to be suitable for Epub UID or filename.
    Removes non-alphanumeric characters and replaces spaces with hyphens.
    """
    sanitized = re.sub(r'[^\w\s-]', '', text)
    sanitized = re.sub(r'\s+', '-', sanitized)
    return sanitized.lower()

def _load_chapter_content(file_path: str, chapter_title: str, chapter_uid: str) -> epub.EpubHtml:
    """
    Loads an HTML file and creates an EpubHtml object.
    The content is expected to be a full HTML document generated by the processor.
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            html_content = f.read()

        # Create EpubHtml item
        # The file_name inside the EPUB will be .xhtml
        chapter_item = epub.EpubHtml(
            title=chapter_title,
            file_name=f'{_sanitize_id(chapter_uid)}.xhtml',
            uid=chapter_uid
        )
        chapter_item.content = html_content
        chapter_item.is_chapter = True
        return chapter_item
    except FileNotFoundError:
        print(f"ERROR: Chapter file not found: {file_path}")
        return None
    except IOError as e:
        print(f"ERROR: Could not read chapter file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"ERROR: An unexpected error occurred while loading chapter {file_path}: {e}")
        return None

def build_epubs_for_story(input_folder: str, output_folder: str, chapters_per_epub: int = 50, author_name: str = "Unknown Author", story_title: str = "Unknown Story"):
    """
    Builds EPUB files from processed HTML chapters.
    Divides the story into multiple EPUBs if chapters_per_epub is set.
    """
    if not os.path.isdir(input_folder):
        print(f"ERROR: Input folder '{input_folder}' not found or is not a directory.")
        return

    if not os.path.exists(output_folder):
        print(f"Creating output folder for EPUBs: {output_folder}")
        os.makedirs(output_folder, exist_ok=True)
    else:
        print(f"Using existing output folder for EPUBs: {output_folder}")

    # List and sort chapter files
    chapter_files = sorted([f for f in os.listdir(input_folder) if f.lower().endswith((".html", ".htm"))])
    if not chapter_files:
        print(f"No HTML chapter files found in '{input_folder}'. Skipping EPUB generation.")
        return

    print(f"\nFound {len(chapter_files)} chapter files to process for EPUB creation.")

    # Determine story title for EPUB metadata
    # Try to extract from the first chapter's title if possible, otherwise use provided or default
    first_chapter_path = os.path.join(input_folder, chapter_files[0])
    try:
        with open(first_chapter_path, 'r', encoding='utf-8') as f:
            soup = BeautifulSoup(f.read(), 'html.parser')
            h1_title = soup.find('h1')
            if h1_title:
                story_title_from_file = h1_title.text.strip().split(':')[0].strip() # Assuming format "Chapter X: Story Title"
                if story_title_from_file and "Chapter" not in story_title_from_file and "Capítulo" not in story_title_from_file:
                    story_title = story_title_from_file
    except Exception as e:
        print(f"WARNING: Could not extract story title from first chapter file: {e}. Using default.")


    # Batching logic
    total_chapters = len(chapter_files)
    num_epubs = (total_chapters + chapters_per_epub - 1) // chapters_per_epub # Ceiling division

    print(f"Story will be split into {num_epubs} EPUB(s), with max {chapters_per_epub} chapters per EPUB.")

    for i in range(num_epubs):
        start_index = i * chapters_per_epub
        end_index = min((i + 1) * chapters_per_epub, total_chapters)
        current_batch_files = chapter_files[start_index:end_index]

        if not current_batch_files:
            continue

        part_suffix = f" (Parte {i + 1})" if num_epubs > 1 else ""
        current_epub_title = f"{story_title}{part_suffix}"
        epub_filename_base = _sanitize_id(story_title)
        epub_filename = os.path.join(output_folder, f"{epub_filename_base}{part_suffix.replace(' ', '_').replace('(', '').replace(')', '').lower()}.epub")

        print(f"\n--- Building EPUB: {current_epub_title} ({len(current_batch_files)} chapters) ---")
        print(f"Saving to: {epub_filename}")

        book = epub.EpubBook()

        # Set metadata
        book.set_identifier(f"urn:uuid:{uuid.uuid5(uuid.NAMESPACE_DNS, current_epub_title)}")
        book.set_title(current_epub_title)
        book.add_author(author_name)
        book.set_language('pt-BR') # Assuming Portuguese, adjust if needed
        book.add_metadata('DC', 'date', str(datetime.date.today()))
        book.add_metadata('DC', 'description', f"Arquivado de Royal Road - {story_title}{part_suffix}")

        # Create and add CSS
        style_content = """
body { font-family: sans-serif; line-height: 1.6; margin: 1em; }
h1, h2, h3, h4, h5, h6 { font-family: serif; margin-top: 1em; margin-bottom: 0.5em; }
p { margin-bottom: 1em; text-align: justify; }
/* Add more styles as needed for paragraphs, blockquotes, etc. */
"""
        nav_css = epub.EpubItem(uid="style_nav", file_name="style/nav.css", media_type="text/css", content=style_content)
        book.add_item(nav_css)

        chapters_in_epub = []
        epub_toc = []

        for j, chapter_file in enumerate(current_batch_files):
            full_chapter_path = os.path.join(input_folder, chapter_file)
            # Extract chapter number and title from filename
            match = re.match(r'capitulo_(\d+?)_(.+?)_clean\.html', chapter_file, re.IGNORECASE)
            chapter_num_str = f"{start_index + j + 1:03d}"
            chapter_base_title = f"Capítulo {chapter_num_str}"
            if match:
                chapter_num_from_filename = int(match.group(1))
                chapter_sanitized_name = match.group(2)
                chapter_base_title = f"Capítulo {chapter_num_from_filename}" # Use original chapter number
                # To get a better title for TOC, load the file and read the <h1> or <title>
                try:
                    with open(full_chapter_path, 'r', encoding='utf-8') as f:
                        soup = BeautifulSoup(f.read(), 'html.parser')
                        h1_tag = soup.find('h1')
                        if h1_tag and h1_tag.string:
                            chapter_title = h1_tag.string.strip()
                        else:
                            chapter_title = f"{chapter_base_title}: {chapter_sanitized_name.replace('_', ' ')}"
                except Exception:
                    chapter_title = f"{chapter_base_title}: {chapter_sanitized_name.replace('_', ' ')}"
            else:
                chapter_title = f"Capítulo {start_index + j + 1}" # Fallback if filename parsing fails


            chapter_uid = f"chap_{_sanitize_id(str(start_index + j + 1))}" # Unique ID for the chapter
            chapter_item = _load_chapter_content(full_chapter_path, chapter_title, chapter_uid)

            if chapter_item:
                book.add_item(chapter_item)
                chapters_in_epub.append(chapter_item)
                epub_toc.append(epub.Section(chapter_title, chapter_item))
                print(f"   Added chapter {chapter_num_str}: {chapter_title}")
            else:
                print(f"   WARNING: Could not add chapter {chapter_file} to EPUB due to loading error.")

        if not chapters_in_epub:
            print(f"WARNING: No chapters were successfully added to EPUB '{current_epub_title}'. Skipping save.")
            continue

        # Define table of contents
        book.toc = epub_toc

        # Add default NCX and Nav file
        book.add_item(epub.EpubNcx())
        book.add_item(epub.EpubNav())

        # Define spine (order of chapters in the book)
        book.spine = ['nav'] + chapters_in_epub # 'nav' is for the navigation file

        # Save the EPUB file
        try:
            epub.write_epub(epub_filename, book, {})
            print(f"Successfully created EPUB: {epub_filename}")
        except Exception as e:
            print(f"ERROR: Could not save EPUB '{epub_filename}': {e}")
            print(f"Traceback: {e.__traceback__}")


    print("\nEPUB generation process concluded.")