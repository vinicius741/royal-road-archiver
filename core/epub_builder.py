# core/epub_builder.py
import os
import requests
from ebooklib import epub
from ebooklib.epub import read_epub, EpubHtml, EpubNav # Added EpubHtml, EpubNav here
from bs4 import BeautifulSoup
from typing import Optional, List # List is already here
from core.processor import remove_sentences_from_html_content # Added this import
import re
import uuid  # For unique identifiers
import datetime  # For publication date metadata
import traceback  # For detailed error reporting

def _sanitize_id(text: str) -> str:
    """
    Sanitizes text to be suitable for Epub UID or filename.
    Removes non-alphanumeric characters and replaces spaces with hyphens.
    """
    sanitized = re.sub(r'[^\w\s-]', '', text)
    sanitized = re.sub(r'\s+', '-', sanitized)
    return sanitized.lower()

def _load_chapter_content(file_path: str, chapter_title: str, chapter_uid: str) -> Optional[epub.EpubHtml]:
    """
    Loads an HTML file and creates an EpubHtml object.
    The content is expected to be a full HTML document generated by the processor.
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            html_content = f.read()

        if not html_content.strip():
            print(f"   WARNING: Chapter file {file_path} is empty and will be skipped.")
            return None

        # Ensure the chapter has a <title> tag
        soup = BeautifulSoup(html_content, 'html.parser')
        head = soup.find('head')
        if not head:
            head = soup.new_tag('head')
            if soup.html:
                soup.html.insert(0, head)
            else:
                # If no <html> tag, we are dealing with a fragment.
                # This case should ideally not happen for full XHTML documents.
                # However, to be robust, we can wrap the content in html if needed,
                # or decide that title injection isn't possible/meaningful here.
                # For now, let's assume an <html> tag is present or bs4 handles it.
                # If not, head might not be properly attached.
                # A more robust solution for fragments might be needed if they are common.
                pass # Or handle fragment case explicitly

        if head and not head.find('title'):
            title_tag = soup.new_tag('title')
            title_tag.string = chapter_title
            head.append(title_tag)

        html_content = str(soup)

        # Create EpubHtml item
        chapter_item = epub.EpubHtml(
            title=chapter_title,
            file_name=f'{_sanitize_id(chapter_uid)}.xhtml', # Use .xhtml extension
            uid=chapter_uid,
            lang='en' # Assuming the content is in English, can be parameterized
        )
        chapter_item.content = html_content
        return chapter_item
    except FileNotFoundError:
        print(f"ERROR: Chapter file not found: {file_path}")
        return None
    except IOError as e:
        print(f"ERROR: Could not read chapter file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"ERROR: An unexpected error occurred while loading chapter {file_path}: {e}")
        print(traceback.format_exc())
        return None

def build_epubs_for_story(
    input_folder: str,
    output_folder: str,
    chapters_per_epub: int = 50,
    author_name: str = "Unknown Author",
    story_title: str = "Unknown Story",
    cover_image_url: Optional[str] = None,
    story_description: Optional[str] = None,
    tags: Optional[List[str]] = None,
    publisher_name: Optional[str] = None
):
    """
    Builds EPUB files from processed HTML chapters.
    Divides the story into multiple EPUBs if chapters_per_epub is set.
    Includes additional metadata like cover, description, tags, and publisher.
    """
    if not os.path.isdir(input_folder):
        print(f"ERROR: Input folder '{input_folder}' not found or is not a directory.")
        return

    if not os.path.exists(output_folder):
        print(f"Creating output folder for EPUBs: {output_folder}")
        os.makedirs(output_folder, exist_ok=True)
    else:
        print(f"Using existing output folder for EPUBs: {output_folder}")

    chapter_files = sorted([f for f in os.listdir(input_folder) if f.lower().endswith((".html", ".htm"))])

    if not chapter_files:
        print(f"No HTML chapter files found in '{input_folder}' (after filtering for .html/.htm). Skipping EPUB generation.")
        return

    print(f"\nFound {len(chapter_files)} chapter files to process for EPUB creation:")

    effective_story_title = story_title
    if story_title == "Archived Royal Road Story" or story_title == "Unknown Story":
        try:
            first_chapter_path_for_title = os.path.join(input_folder, chapter_files[0])
            with open(first_chapter_path_for_title, 'r', encoding='utf-8') as f_content:
                soup_title = BeautifulSoup(f_content.read(), 'html.parser')
                h1_title_tag = soup_title.find('h1')
                if h1_title_tag and h1_title_tag.string:
                    extracted_title = h1_title_tag.string.strip()
                    extracted_title = re.sub(r"^(Chapter|CapÃ­tulo)\s*\d+\s*[:\-]\s*", "", extracted_title, flags=re.IGNORECASE).strip()
                    if extracted_title:
                        effective_story_title = extracted_title
                        print(f"   Used title from first chapter's H1 for EPUB: '{effective_story_title}'")
        except Exception as e_title:
            print(f"   WARNING: Could not extract story title from first chapter H1: {e_title}. Using provided/default title: '{story_title}'")


    total_chapters = len(chapter_files)
    effective_chapters_per_epub = chapters_per_epub if chapters_per_epub > 0 else total_chapters
    if total_chapters == 0 :
        print("Error: total_chapters is 0, cannot proceed.")
        return

    num_epubs = (total_chapters + effective_chapters_per_epub - 1) // effective_chapters_per_epub if effective_chapters_per_epub > 0 else 1

    print(f"Story will be split into {num_epubs} EPUB(s), with max {effective_chapters_per_epub} chapters per EPUB.")

    for i in range(num_epubs):
        start_index = i * effective_chapters_per_epub
        end_index = min((i + 1) * effective_chapters_per_epub, total_chapters)
        current_batch_files = chapter_files[start_index:end_index]

        if not current_batch_files:
            continue

        # Determine chapter numbers for the current batch (1-indexed)
        first_chapter_number_in_batch = start_index + 1
        last_chapter_number_in_batch = end_index

        # Update EPUB metadata title to include chapter range
        current_epub_title_suffix: str
        if num_epubs > 1:
            current_epub_title_suffix = f" (Ch {first_chapter_number_in_batch}-{last_chapter_number_in_batch})"
        elif total_chapters > 0: # Single volume
             current_epub_title_suffix = f" (Ch 1-{last_chapter_number_in_batch})" # last_chapter_number_in_batch would be total_chapters
        else: # No chapters, edge case
            current_epub_title_suffix = ""
        current_epub_title = f"{effective_story_title}{current_epub_title_suffix}"

        # New EPUB filename generation including chapter numbers
        filename_chapter_prefix = f"Ch{first_chapter_number_in_batch:03d}-Ch{last_chapter_number_in_batch:03d}"
        epub_filename_story_part = _sanitize_id(effective_story_title if effective_story_title and effective_story_title != "Unknown Story" else "story")
        epub_filename = os.path.join(output_folder, f"{filename_chapter_prefix}_{epub_filename_story_part}.epub")

        print(f"\n--- Building EPUB: {current_epub_title} ({len(current_batch_files)} chapters) ---")
        print(f"Saving to: {epub_filename}")

        book = epub.EpubBook()
        book.set_identifier(f"urn:uuid:{uuid.uuid5(uuid.NAMESPACE_DNS, current_epub_title)}") # Use updated title for UID
        book.set_title(current_epub_title)
        book.add_author(author_name)
        book.set_language('en')

        # Publisher
        if publisher_name and publisher_name.strip():
            book.add_metadata('DC', 'publisher', publisher_name)
        else:
            book.add_metadata('DC', 'publisher', 'Royal Road Archiver') # Default

        book.add_metadata('DC', 'date', datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), {'id': 'pubdate'})

        # Description
        if story_description and story_description.strip():
            book.add_metadata('DC', 'description', story_description)
        else:
            book.add_metadata('DC', 'description', f"Archived from Royal Road - {current_epub_title}") # Default

        # Tags (Subjects)
        if tags: # Check if tags list is not None and not empty
            for tag_string in tags:
                if tag_string and tag_string.strip(): # Ensure tag is not empty
                    book.add_metadata('DC', 'subject', tag_string.strip())

        # Cover Image
        if cover_image_url:
            try:
                print(f"   Attempting to download cover image from: {cover_image_url}")
                response = requests.get(cover_image_url, stream=True, timeout=15)
                response.raise_for_status()
                
                image_content = response.content
                content_type = response.headers.get('Content-Type')
                
                image_filename = "cover.jpg" # Default filename
                if content_type:
                    if 'image/jpeg' in content_type:
                        image_filename = "cover.jpg"
                    elif 'image/png' in content_type:
                        image_filename = "cover.png"
                    elif 'image/gif' in content_type:
                        image_filename = "cover.gif"
                    elif 'image/webp' in content_type: 
                        print(f"   WARNING: Cover image is WEBP ({content_type}), which might not be universally supported in EPUBs. Attempting as JPEG.")
                        image_filename = "cover.webp" 
                    else:
                        print(f"   WARNING: Unknown cover image Content-Type '{content_type}'. Defaulting to cover.jpg.")
                else: # Try to infer from URL
                    url_ext = os.path.splitext(cover_image_url)[1].lower()
                    if url_ext in ['.jpg', '.jpeg']:
                        image_filename = "cover.jpg"
                    elif url_ext == '.png':
                        image_filename = "cover.png"
                    elif url_ext == '.gif':
                         image_filename = "cover.gif"
                    else:
                        print("   WARNING: Could not determine cover image type from headers or URL. Defaulting to cover.jpg.")

                book.set_cover(image_filename, image_content) 
                print(f"   Cover image '{image_filename}' added to EPUB.")

                # Ensure cover.xhtml has the title "Cover"
                for item in book.get_items_of_type(epub.ITEM_DOCUMENT):
                    if item.get_name() == 'cover.xhtml' or item.file_name == 'cover.xhtml': # Check both name and file_name for robustness
                        try:
                            cover_html_content = item.get_content().decode('utf-8')
                            cover_soup = BeautifulSoup(cover_html_content, 'html.parser')

                            head = cover_soup.find('head')
                            if not head:
                                head = cover_soup.new_tag('head')
                                # Try to insert it into <html>, or at the beginning if no <html>
                                html_tag = cover_soup.find('html')
                                if html_tag:
                                    html_tag.insert(0, head)
                                else:
                                    cover_soup.insert(0, head)

                            title_tag = head.find('title')
                            if not title_tag:
                                title_tag = cover_soup.new_tag('title')
                                head.append(title_tag)

                            title_tag.string = "Cover"
                            item.set_content(str(cover_soup).encode('utf-8'))
                            print(f"   Updated title for '{item.file_name}' to 'Cover'.")
                        except Exception as e_cover_title:
                            print(f"   WARNING: Could not update title for cover.xhtml: {e_cover_title}")
                        break # Found and processed cover.xhtml, no need to continue loop

            except requests.exceptions.RequestException as e_cover:
                print(f"   WARNING: Failed to download cover image from {cover_image_url}: {e_cover}")
            except Exception as e_cover_generic:
                print(f"   WARNING: An unexpected error occurred while processing cover image: {e_cover_generic}")

        style_content = """
body { font-family: sans-serif; line-height: 1.6; margin: 1em; padding: 0; background-color: #fdfdfd; color: #111; }
h1, h2, h3, h4, h5, h6 { font-family: serif; margin-top: 1.5em; margin-bottom: 0.5em; line-height: 1.2; color: #333; }
h1 { font-size: 2em; text-align: center; }
h2 { font-size: 1.75em; }
p { margin-bottom: 1em; text-align: justify; text-indent: 1.5em; }
p.noindent { text-indent: 0; }
hr { border: 0; height: 1px; background: #ccc; margin: 2em auto; width: 50%;}
.chapter-content { max-width: 800px; margin: 0 auto; padding: 1em; }
img, svg { max-width: 100%; height: auto; display: block; margin: 1em auto; border: 1px solid #eee; }
        """
        default_css = epub.EpubItem(uid="style_default", file_name="style/default.css", media_type="text/css", content=style_content.encode('utf-8'))
        book.add_item(default_css)

        epub_chapters_for_spine = []
        epub_toc_links = []

        for chap_idx, chapter_file_name in enumerate(current_batch_files):
            full_chapter_path = os.path.join(input_folder, chapter_file_name)
            
            chapter_display_title_from_h1 = f"Chapter {start_index + chap_idx + 1}" # Fallback
            try:
                with open(full_chapter_path, 'r', encoding='utf-8') as f_chap:
                    chap_soup = BeautifulSoup(f_chap.read(), 'html.parser')
                    h1_tag = chap_soup.find('h1')
                    if h1_tag and h1_tag.string:
                        chapter_display_title_from_h1 = h1_tag.string.strip()
            except Exception as e_chap_title:
                print(f"   WARNING: Could not read H1 title from {chapter_file_name}: {e_chap_title}. Using fallback title.")

            chapter_uid = f"chap_{_sanitize_id(os.path.splitext(chapter_file_name)[0])}_{i}_{chap_idx}"

            epub_chapter = _load_chapter_content(full_chapter_path, chapter_display_title_from_h1, chapter_uid)

            if epub_chapter:
                epub_chapter.add_item(default_css) 
                book.add_item(epub_chapter)
                epub_chapters_for_spine.append(epub_chapter)
                epub_toc_links.append(epub.Link(href=epub_chapter.file_name, title=chapter_display_title_from_h1, uid=chapter_uid))
                print(f"   Added chapter to EPUB: {chapter_display_title_from_h1} (File: {epub_chapter.file_name})")
            else:
                print(f"   WARNING: Could not load content for chapter {chapter_file_name}. It will be skipped.")

        if not epub_chapters_for_spine:
            print(f"WARNING: No chapters were successfully prepared for EPUB '{current_epub_title}'. Skipping save.")
            continue

        book.toc = tuple(epub_toc_links)
        book.add_item(epub.EpubNcx())
        book.add_item(epub.EpubNav()) 

        book.spine = ['nav'] + epub_chapters_for_spine

        try:
            print(f"   Attempting to write EPUB file: {epub_filename}")
            epub.write_epub(epub_filename, book, {"epub3_pages": False, "toc_depth": 2})
            print(f"Successfully created EPUB: {epub_filename}")
        except Exception as e_write:
            print(f"ERROR: Could not save EPUB '{epub_filename}': {e_write}")
            print(f"Traceback for EPUB write error:\n{traceback.format_exc()}")

    print("\nEPUB generation process concluded.")


def load_epub_for_modification(epub_file_path: str) -> Optional[epub.EpubBook]:
    """Loads an EPUB file for modification.

    Args:
        epub_file_path: The path to the EPUB file.

    Returns:
        The EpubBook object if successful, None otherwise.
    """
    try:
        book = read_epub(epub_file_path)
        return book
    except FileNotFoundError:
        print(f"Error: EPUB file not found at {epub_file_path}")
        return None
    except epub.EpubException as e:
        print(f"Error reading EPUB file {epub_file_path}: {e}")
        return None


def modify_epub_content(epub_path: str, sentences_to_remove: List[str]):
    """Modifies the content of an EPUB file by removing specified sentences.

    Args:
        epub_path: The path to the EPUB file.
        sentences_to_remove: A list of sentences to remove.
    """
    book = load_epub_for_modification(epub_path)
    if not book:
        print(f"Error: Could not load EPUB: {epub_path}")
        return

    modified = False
    for item in book.get_items():
        if isinstance(item, (EpubHtml, EpubNav)): # Check for EpubHtml or EpubHtmlNav
            try:
                original_html_content = item.get_content().decode('utf-8', errors='ignore')
                modified_html_content = remove_sentences_from_html_content(original_html_content, sentences_to_remove)

                if original_html_content != modified_html_content:
                    item.set_content(modified_html_content.encode('utf-8'))
                    modified = True
            except Exception as e:
                print(f"Error processing item {item.get_name()} in {epub_path}: {e}")

    if modified:
        output_epub_path = epub_path # Overwrite original file
        # Optional: Backup original file
        # backup_path = epub_path + ".bak"
        # try:
        #     os.rename(epub_path, backup_path)
        #     print(f"Backup of original EPUB created at: {backup_path}")
        # except OSError as e:
        #     print(f"Error creating backup for {epub_path}: {e}. Proceeding without backup.")

        try:
            epub.write_epub(output_epub_path, book, {}) # epub.write_epub options can be added if needed
            print(f"Successfully modified and saved EPUB: {output_epub_path}")
        except Exception as e:
            print(f"Error saving modified EPUB {output_epub_path}: {e}")
            # Optional: Restore backup if saving failed
            # if os.path.exists(backup_path):
            #     try:
            #         os.rename(backup_path, epub_path)
            #         print(f"Restored original EPUB from backup: {epub_path}")
            #     except OSError as re:
            #         print(f"Error restoring backup for {epub_path}: {re}")
    else:
        print(f"No changes made to EPUB: {epub_path}")


def fix_xhtml_titles_in_epub(book: epub.EpubBook) -> bool:
    """
    Scans all XHTML items in an EpubBook and ensures they have a <title> tag
    in their <head> section.

    For chapter files, it tries to use the item's manifest title if available and sensible,
    otherwise generates a title from the filename.
    For 'cover.xhtml', it sets the title to 'Cover'.

    Args:
        book: The ebooklib.epub.EpubBook object to modify.

    Returns:
        True if any modifications were made to the book's items, False otherwise.
    """
    overall_modified_status = False # Tracks if any item in the book was changed

    for item in book.get_items_of_type(epub.ITEM_DOCUMENT):
        if not (item.get_name().lower().endswith(('.xhtml', '.html'))):
            continue

        item_modified_this_iteration = False # Tracks if this specific item was changed
        try:
            original_content = item.get_content().decode('utf-8', errors='ignore')
            soup = BeautifulSoup(original_content, 'html.parser')

            head = soup.find('head')
            if not head:
                head = soup.new_tag('head')
                html_tag = soup.find('html')
                if html_tag:
                    html_tag.insert(0, head) # Prepend head to html tag
                else:
                    # If no html tag, we might try to add one or wrap content
                    # For now, let's assume a basic structure or skip problematic files
                    print(f"   WARNING: No <html> tag found in {item.get_name()}, attempting to add basic structure for title fix.")
                    # Create html and body tags if they don't exist
                    if not soup.find('html'):
                        new_html_tag = soup.new_tag('html')
                        new_body_tag = soup.new_tag('body')
                        new_html_tag.append(head) # head is already created
                        new_html_tag.append(new_body_tag)
                        # Move existing content into body, if any direct children of soup
                        for child_content in list(soup.contents):
                            new_body_tag.append(child_content.extract())
                        soup.append(new_html_tag)
                    else: # html tag exists, but no head was found initially. head is already created and added to html.
                        pass


            title_tag = head.find('title')

            desired_title_text = ""
            # Check if it's cover.xhtml based on typical naming by ebooklib or common use
            # ebooklib's set_cover often names the XHTML file 'cover.xhtml' and gives it id 'cover'
            if item.get_name().lower() == 'cover.xhtml' or item.id.lower() == 'cover':
                desired_title_text = "Cover"
            else:
                # Attempt to use the item's title from manifest (e.g., set via book.add_item or chapter loading)
                # item.title is part of the Dublin Core metadata for the item in OPF
                if hasattr(item, 'title') and item.title and item.title.strip().lower() not in ['none', 'untitled', '']:
                    # This 'title' attribute on the item is often what appears in the TOC or manifest
                    # and should be a good candidate for the HTML <title>.
                    desired_title_text = item.title.strip()
                else:
                    # Fallback: generate a title from filename
                    filename_sans_ext = os.path.splitext(item.get_name())[0]
                    # Basic beautification: replace underscores/hyphens, capitalize
                    processed_filename = filename_sans_ext.replace('_', ' ').replace('-', ' ')
                    desired_title_text = ' '.join(word.capitalize() for word in processed_filename.split() if word)
                    if not desired_title_text: # Ultimate fallback
                        desired_title_text = "Untitled Document"

            if not title_tag:
                title_tag = soup.new_tag('title')
                title_tag.string = desired_title_text
                head.append(title_tag)
                item_modified_this_iteration = True
            elif title_tag.string != desired_title_text:
                title_tag.string = desired_title_text
                item_modified_this_iteration = True

            if item_modified_this_iteration:
                item.set_content(str(soup).encode('utf-8'))
                overall_modified_status = True
                # print(f"   INFO: Applied title '{desired_title_text}' to {item.get_name()}")

        except Exception as e:
            print(f"   ERROR: Could not process item {item.get_name()} in fix_xhtml_titles_in_epub: {e}")
            # import traceback
            # print(traceback.format_exc())

    return overall_modified_status