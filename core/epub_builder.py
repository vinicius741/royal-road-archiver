# core/epub_builder.py
import os
from ebooklib import epub
from bs4 import BeautifulSoup
import re
import uuid # For unique identifiers
import datetime # For publication date metadata
import traceback # For detailed error reporting
from typing import Optional, Callable # For LoggerCallback

# Define LoggerCallback type alias, similar to main.py
LoggerCallback = Optional[Callable[[str, Optional[str]], None]]

def _sanitize_id(text: str) -> str:
    """
    Sanitizes text to be suitable for Epub UID or filename.
    Removes non-alphanumeric characters and replaces spaces with hyphens.
    """
    sanitized = re.sub(r'[^\w\s-]', '', text)
    sanitized = re.sub(r'\s+', '-', sanitized)
    return sanitized.lower()

def _load_chapter_content(file_path: str, chapter_title: str, chapter_uid: str, logger_callback: LoggerCallback = None) -> epub.EpubHtml | None:
    """
    Loads an HTML file and creates an EpubHtml object.
    The content is expected to be a full HTML document generated by the processor.
    """
    log = lambda msg, style=None: logger_callback(msg, style) if logger_callback else print(msg)

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            html_content = f.read()

        if not html_content.strip():
            log(f"   WARNING: Chapter file {file_path} is empty and will be skipped.", "yellow")
            return None

        chapter_item = epub.EpubHtml(
            title=chapter_title,
            file_name=f'{_sanitize_id(chapter_uid)}.xhtml',
            uid=chapter_uid,
            lang='en'
        )
        chapter_item.content = html_content
        return chapter_item
    except FileNotFoundError:
        log(f"ERROR: Chapter file not found: {file_path}", "red")
        return None
    except IOError as e:
        log(f"ERROR: Could not read chapter file {file_path}: {e}", "red")
        return None
    except Exception as e:
        log(f"ERROR: An unexpected error occurred while loading chapter {file_path}: {e}", "red")
        log(traceback.format_exc(), "yellow")
        return None

def build_epubs_for_story(input_folder: str, output_folder: str, chapters_per_epub: int = 50, author_name: str = "Unknown Author", story_title: str = "Unknown Story", logger_callback: LoggerCallback = None):
    """
    Builds EPUB files from processed HTML chapters.
    Divides the story into multiple EPUBs if chapters_per_epub is set.
    """
    log = lambda msg, style=None: logger_callback(msg, style) if logger_callback else print(msg)

    if not os.path.isdir(input_folder):
        log(f"ERROR: Input folder '{input_folder}' not found or is not a directory.", "red")
        return

    if not os.path.exists(output_folder):
        log(f"Creating output folder for EPUBs: {output_folder}")
        os.makedirs(output_folder, exist_ok=True)
    else:
        log(f"Using existing output folder for EPUBs: {output_folder}")

    chapter_files = sorted([f for f in os.listdir(input_folder) if f.lower().endswith((".html", ".htm"))])

    if not chapter_files:
        log(f"No HTML chapter files found in '{input_folder}' (after filtering for .html/.htm). Skipping EPUB generation.", "yellow")
        return

    log(f"\nFound {len(chapter_files)} chapter files to process for EPUB creation:")

    effective_story_title = story_title
    if story_title == "Archived Royal Road Story" or story_title == "Unknown Story":
        try:
            first_chapter_path_for_title = os.path.join(input_folder, chapter_files[0])
            with open(first_chapter_path_for_title, 'r', encoding='utf-8') as f_content:
                soup_title = BeautifulSoup(f_content.read(), 'html.parser')
                h1_title_tag = soup_title.find('h1')
                if h1_title_tag and h1_title_tag.string:
                    extracted_title = h1_title_tag.string.strip()
                    extracted_title = re.sub(r"^(Chapter|CapÃ­tulo)\s*\d+\s*[:\-]\s*", "", extracted_title, flags=re.IGNORECASE).strip()
                    if extracted_title:
                        effective_story_title = extracted_title
                        log(f"   Used title from first chapter's H1 for EPUB: '{effective_story_title}'")
        except Exception as e_title:
            log(f"   WARNING: Could not extract story title from first chapter H1: {e_title}. Using provided/default title: '{story_title}'", "yellow")

    total_chapters = len(chapter_files)
    effective_chapters_per_epub = chapters_per_epub if chapters_per_epub > 0 else total_chapters
    if total_chapters == 0 :
        log("Error: total_chapters is 0, cannot proceed.", "red")
        return

    num_epubs = (total_chapters + effective_chapters_per_epub - 1) // effective_chapters_per_epub if effective_chapters_per_epub > 0 else 1

    log(f"Story will be split into {num_epubs} EPUB(s), with max {effective_chapters_per_epub} chapters per EPUB.")

    for i in range(num_epubs):
        start_index = i * effective_chapters_per_epub
        end_index = min((i + 1) * effective_chapters_per_epub, total_chapters)
        current_batch_files = chapter_files[start_index:end_index]

        if not current_batch_files:
            continue

        first_chapter_number_in_batch = start_index + 1
        last_chapter_number_in_batch = end_index

        current_epub_title_suffix: str
        if num_epubs > 1:
            current_epub_title_suffix = f" (Ch {first_chapter_number_in_batch}-{last_chapter_number_in_batch})"
        elif total_chapters > 0:
             current_epub_title_suffix = f" (Ch 1-{last_chapter_number_in_batch})"
        else:
            current_epub_title_suffix = ""
        current_epub_title = f"{effective_story_title}{current_epub_title_suffix}"

        filename_chapter_prefix = f"Ch{first_chapter_number_in_batch:03d}-Ch{last_chapter_number_in_batch:03d}"
        epub_filename_story_part = _sanitize_id(effective_story_title if effective_story_title and effective_story_title != "Unknown Story" else "story")
        epub_filename = os.path.join(output_folder, f"{filename_chapter_prefix}_{epub_filename_story_part}.epub")

        log(f"\n--- Building EPUB: {current_epub_title} ({len(current_batch_files)} chapters) ---")
        log(f"Saving to: {epub_filename}")

        book = epub.EpubBook()
        book.set_identifier(f"urn:uuid:{uuid.uuid5(uuid.NAMESPACE_DNS, current_epub_title)}")
        book.set_title(current_epub_title)
        book.add_author(author_name)
        book.set_language('en')
        book.add_metadata('DC', 'publisher', 'Royal Road Archiver')
        book.add_metadata('DC', 'date', datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'), {'id': 'pubdate'})
        book.add_metadata('DC', 'description', f"Archived from Royal Road - {current_epub_title}")

        style_content = """
body { font-family: sans-serif; line-height: 1.6; margin: 1em; padding: 0; background-color: #fdfdfd; color: #111; }
h1, h2, h3, h4, h5, h6 { font-family: serif; margin-top: 1.5em; margin-bottom: 0.5em; line-height: 1.2; color: #333; }
h1 { font-size: 2em; text-align: center; }
h2 { font-size: 1.75em; }
p { margin-bottom: 1em; text-align: justify; text-indent: 1.5em; }
p.noindent { text-indent: 0; }
hr { border: 0; height: 1px; background: #ccc; margin: 2em auto; width: 50%;}
.chapter-content { max-width: 800px; margin: 0 auto; padding: 1em; }
img, svg { max-width: 100%; height: auto; display: block; margin: 1em auto; border: 1px solid #eee; }
        """
        default_css = epub.EpubItem(uid="style_default", file_name="style/default.css", media_type="text/css", content=style_content.encode('utf-8'))
        book.add_item(default_css)

        epub_chapters_for_spine = []
        epub_toc_links = []

        for chap_idx, chapter_file_name in enumerate(current_batch_files):
            full_chapter_path = os.path.join(input_folder, chapter_file_name)
            
            chapter_display_title_from_h1 = f"Chapter {start_index + chap_idx + 1}"
            try:
                with open(full_chapter_path, 'r', encoding='utf-8') as f_chap:
                    chap_soup = BeautifulSoup(f_chap.read(), 'html.parser')
                    h1_tag = chap_soup.find('h1')
                    if h1_tag and h1_tag.string:
                        chapter_display_title_from_h1 = h1_tag.string.strip()
            except Exception as e_chap_title:
                log(f"   WARNING: Could not read H1 title from {chapter_file_name}: {e_chap_title}. Using fallback title.", "yellow")

            chapter_uid = f"chap_{_sanitize_id(os.path.splitext(chapter_file_name)[0])}_{i}_{chap_idx}"

            epub_chapter = _load_chapter_content(full_chapter_path, chapter_display_title_from_h1, chapter_uid, logger_callback)

            if epub_chapter:
                epub_chapter.add_item(default_css) 
                book.add_item(epub_chapter)
                epub_chapters_for_spine.append(epub_chapter)
                epub_toc_links.append(epub.Link(href=epub_chapter.file_name, title=chapter_display_title_from_h1, uid=chapter_uid))
                log(f"   Added chapter to EPUB: {chapter_display_title_from_h1} (File: {epub_chapter.file_name})")
            else:
                log(f"   WARNING: Could not load content for chapter {chapter_file_name}. It will be skipped.", "yellow")

        if not epub_chapters_for_spine:
            log(f"WARNING: No chapters were successfully prepared for EPUB '{current_epub_title}'. Skipping save.", "yellow")
            continue

        book.toc = tuple(epub_toc_links)
        book.add_item(epub.EpubNcx())
        book.add_item(epub.EpubNav()) 

        book.spine = ['nav'] + epub_chapters_for_spine

        try:
            log(f"   Attempting to write EPUB file: {epub_filename}")
            epub.write_epub(epub_filename, book, {"epub3_pages": False, "toc_depth": 2})
            log(f"Successfully created EPUB: {epub_filename}", "green")
        except Exception as e_write:
            log(f"ERROR: Could not save EPUB '{epub_filename}': {e_write}", "red")
            log(f"Traceback for EPUB write error:\n{traceback.format_exc()}", "yellow")

    log("\nEPUB generation process concluded.")